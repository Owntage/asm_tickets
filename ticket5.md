# Билет 5
# Ванечка в этом билете еще ожидает услышать различия х86 от х16

## различия x86 / x64



64-битное расширение х86. Называется по-разному (интел и амд называют одно и то же по-разному). Расширение называется amd64. Т.е. когда вышло, все его называли так. Но интелу не нравилось амд в начале, так что они придумали em64. Сейчас это называется x86-64. Ну либо просто x64. Ну а 86-битный режим называется как назывался. Таблицы страниц устроены так же. 

## Что изменилось, а также интересные фичи
#### Integer 64
Все операции стали оперировать 64х-битными интами.

#### Новые регистры

Были добавлены новые регисры:

1) 16 целочисленных 64-битных регистра общего назначения (RAX, RBX, RCX, RDX, RBP, RSI, RDI, RSP, R8 — R15). При этом мы все еще можем обращаться к регистрам x86, так как они являются младшей частью новых;

2) 16 128-битных регистров SSE (XMM0 — XMM15);

3) 64-битный указатель RIP и 64-битный регистр флагов RFLAGS.

#### Больше памяти

1) Была поднята планка объема виртуальной памяти с 4GB для х86 до 256TB для x64.

2) Также был увеличен поддерживаемый объем RAM с 64GB у x86 до 1TB у х64.

#### Дешевая адресация

Был предоставлен отдельный адресный регистр - RIP - для работы с адресами. Кроме увеличения скорости адресных операций, он позволяет сделать более эффективным position-independed code (см. внизу, там есть чуточка про это). Обычно адресно-независимыми являются библиотеки и код, подгружаемый во время работы программы.


#### No-Execute Bit

Ребята из AMD решили заняться безопасностью кода и назвали 63ий бит в page table entry No-Execute Bit (NX). Он помогает системе определить какие страницы содержат исполняемый код, а какие нет. Попытка исполнить код из страницы с пометкой No-Execute приведет к той же ошибке, что и попытка записи в read-only страницу. Это позволяет избежать некоторых неприятных ошибок с памятью. Примерно для той же цели мы использовали сегментные дескрипторы в 80286.

#### Устранение рудиментов

В x64 устранили сегментную адресацию. Сначала AMD порадовались, но потом поняли, что будут косяки с виртуализацией. Например, когда мы хотим поставить две системы, без сегментного механизма очень трудно управлять I/O. Таким образом, в более поздней редакции x64 присутствуют два сегмента - FS и GS, которые нужны специально для виртуализации. Т.е. сегментация есть, но достаточно ограниченная.
#FS/GS нужен для того, чтобы там хранить указатель на thread local storage.

Также были устранены virtual 8086 mode (см. второй тикет - А20) и TSS. 

### Long Mode

Собственно, новый режим работы с 64х-битными инструкциями и регистрами. Характерен тем, что абсолютно не умеет выполнять программы написанные под real mode и virtual 8086 mode. Даже не пытайтесь.

64х-битные программы запускаться в так называемом 64х-битном подмоде, а 16и- и 32х-битные protected mode программы запускаются в режиме совместимости.

#### REX prefix

Так как у нас теперь все 64х-битное, то нужны и новые комманды. Для этого изобрели так называемый REX prefix. Благодаря ему мы теперь можем кодировать "длинные" комманды, но взамен ВСЕ комманды стали длиннее на 1 байт.

Откуда взялся REX prefix? Что-бы что-то вставить в код комманд, нужно что-то удалить. Где они нашли в пространстве комманд больше 1 байта?

Они пожертвовали короткими формами комманд inc, dec. В 32 они были у всех 8-битных и у всех 16-битных. Т.е. всего 32 комманды. В Long Mode ими пожертвовали, чтобы получить REX prefix. Но это не так уж и страшно, потому что всё равно остались длинные версии комманд.

(В чём разница между inc и add? inc не меняет carry flag.) 

#### Изменения в работе операций

##### Как работают операции? 

В 32-битном режиме, если что-то записано в eax, а потом перетираются младшие биты, то после этого в eax будет старшая часть без изменений, а младшая часть перетрётся. Но в 64 версии перетирается старшая часть, когда меняется младшая. Т.к. процессор не знает, нужна ли нам часть или нет, то выполнение арифметической операции зависит от предыдущей команды.

##### Partial Register Pipeline

Суть в том, что в зависимости от того, используется старшая часть или нет, конвеер ведёт себя по-разному. Так что чтобы всё было быстрее, нужно в явном виде сделать xor по переменной. 

В 64 битном режиме всегда записывается регистр целиком, т.е. нет partial write. А если регистр перетирается всегда целиком, то уже нет этой проблемы с конвеерм. 

Чтобы избежать partial write, gcc всегда использует add. 

В остальном, код для 32 и для 64, который генерится, очень похож. 

### Legacy Mode

Вот эта штучка позволяет работать с чисто 16и- и 32х-битными системами. Естественно, запрещены 64х-битные комманды и инструкции. Сам процессор при этом работает как 32х-битный х86.

### Поддержка position-independent кода. 
#### Мнение Влада по этому вопросу

Хуета какая-то написана

Суть в том, что раньше нельзя было для mov задавать операнд через относительный адрес. Теперь можно. И в итоге все обращения к глобальным переменным ебашут так. Раньше было трудно и дорого.

#### какая раньше была проблема

Есть программы, у каждой своё адресное пространство на 4 гб. 

Все программы загружалисть в какое-то одно место. (exe). Проблема в том, что есть ещё dll. И они загружаются в память тогда, когда программа уже работает. И память может быть уже занята. 

А что, если код программы просто взять и переместить куда-то в другое место? jump & call продолжат работать, потому что они - относительные. Но сломаются обращения к глобальным переменным. Кроме того, сломаются таблицы виртуальных функций. Обычно это не проблема, потому что код загружается просто по фиксированному адресу, даже в длл. Т.е. у длл есть адрес, куда загрузиться. И у каждой длл свой. Но если мы не знаем наперёд, какие будут длл, то есть 2 варианта. Первый вариант: все места с глобальными обращениями переделывать (помечать). Таблица релокаций - там, где хранятся глобальные адреса. Самое простое действие - просто сместить все адреса. Но недостаток в том, что dll не будут шарить код. Т.е. для каждого процесса код длл копируется. А это плохо, потому что тогда любой хелло ворлд будет по 50-100 мегабайт. Поэтому сделали так: у каждой длл есть какой-то base address. Т.е. адрес, куда нужно загружаться. Если память там свободна, то ничего не релацируется.  Винда использует memory mapped files, оперативка тратиться не будет. Но если память по base_address занята, то делается релокация. 

Есть код, который называется position-independent. Это такой код, который не надо релоцировать. И под линуксом все .so скомпилированны именно так. Т.е. в любом месте ищется свободное место, там мепается файл и библиотека загружается туда. 

#### Проблема - сделать обращения к глобальным переменным относительно регистра ip. Как получить регистр ip без move? 

call label
label: pop ebx

Но так не делают. 

у процессора внутри есть много механизмов для того, чтобы сделать более быстрое выполнение. Так что можно этим воспользоваться и немного переписать код. Пары call & ret почти всегда совпадают, так что на самом деле у процессора есть ещё один стек для возвращаемых значений. Так что если не сделать ret, то все последующие возвраты будут медленными. 

### NOP и зануление

Есть комманда nop. Что она делает? Меняет регистр сам с собой. 

иногда нужно сделать так, чтобы метка была выровнена по какому-то адресу. Но много нопов нельзя вставлять, т.к. он тоже как бы вычисляется и тратит время. Так что есть nop'ы разной длины. 

xor - рекомендованный способ занулять регистр. Поэтому, если xor регистра с ним же, то нет зависимости от его значения. Если бы такая зависимость была, то это называлось бы false-dependency. 

popcount - считает число битов-единичек в регистре и записывает в eax.  

Эта команда похожа на всякие add, xor и т.д. И взяли и сделали popcount так же. Но арифметические операции все зависят от первого агрумента. И с popcount получилось так же. Если бы компилятор знал про false-dependency, то проблемы бы не было. 

Количество трюков, скажем, с false dependency на редких коммандах просто зашкаливает. 

[<<](https://github.com/Owntage/asm_tickets/blob/master/ticket4.md) [>>](https://github.com/Owntage/asm_tickets/blob/master/ticket6.md)
