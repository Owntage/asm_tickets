# Билет 2
## Сегментная адресация

особенность x86. в большинстве других архитектур ничего подобного нет. 

в 8086 были 16-битные указатели. Но можно было адресоваться к миллиону ячеек. Мил - это порядка 2^20. Откуда ещё 4 бита? На самом деле, адрес хранился в 2 числах - сегмент и смещение. 

к одной ячейке можно обратиться разными способами. Потому что реальный адрес получается по формуле 
seg * 16 + off.

### A20 Line (https://en.wikipedia.org/wiki/A20_line)
Эта штука нужна для обратной совместимости с 808х и 80186. На них была 20и-разрядная адресная шина, поэтому мы могли юзать только 1 мегабайт(2^20 бит) адресов. Но, так как мы все адреса хранили в виде сегмент : смещение, естественно, что могло возникнуть переполнение адреса. Так, адрес FFFF:0010 был эквивалентен адресу 0000:0000 из-за потери бита, который лежит свыше 20ого. Эта фича активно использовалась многими досовскими программами. Логично, что при переходе на 80286 с 24х-разрядной адресной шиной, такие программы переставали работать. Тогда был придуман А20-GATE, который позволял отключать 21ый провод шины. По-умолчанию он включен и управляется через контроллер клавиатуры(where is logic?). Позднее был придуман a20 handler, который динамически управляет адресацией и позволяет программам, работающим в реальном режиме(см. далее), использовать адреса от FFFF:0010 до FFFF:FFFF.

допустим, что регистры - 16 бит. Команда обращения к памяти имеет 1 аргумент - это 16-байтовый регистр. А где лежит второе число? (сегмент). В специальном регистре. ds (data segment). Есть несколько регистров, которые указывают на сегменты. Напремер, data segment, или stack segment, cs( maybe call).

ещё есть es, fs, gs (e - extended)

можно указать другой регистр: mov ax, es : [bx].

регистры типа sp, bp имеют дефолтный регистр sp. 

Перед коммандами, которые работают с памятью, можно указать префикс, который заставит комманду использовать другой регистр для сегмента.

Комманды, которые используют регистры разного размера, имеют разные префиксы. Есть префикс изменения разрядности. 

процессор может работать в двух режимах: в режиме совместимости и в новом режиме. Если в 16-битном коде начать работать с 32-битными коммандами, то комманды будут больше из-за префикса. Тоже самое и в 32-битном режиме при работе с 16-битными коммандами.

Есть и другие префиксы. Например, префикс lock. Он делает комманду атомарной. 

Одна комманда может иметь несколько префиксов и все они будут работать. Это позволяет делать очень длинные комманды. 

А что будет, если указать много префиксов изменения разрядности? Так никто не пишет обычно, но если написать, то поведение, видимо, зависит от процессора. Например, в amd будет использоваться последний префикс.

Для 8086 операционной системой была dos. Дос - это однозадачная система. Программы клались как бы на стек. Работала та, которая находилась на вершине стека. Сама система лежала где-то вначале памяти.

т.к. была возможность обратиться ко всей памяти, то программа должна была знать, в какой части памяти она начинается. И такая информация хранилась как раз в сегментном регистре.

(т.е. у каждой программы свой сегмент).

было соглашение, что вся доступная память после программы является свободной. 

в x86 были какие-то уникальные комманды.
movs{b,w,d} //разная буква - разный регистр с индексом
loads{b,w,d}
shos{b,w,d}

loadsb делает mov al, [si], lea si, [si + 1]

префикс rep говорит, что комманду нужно повторять cx раз

Кстати, простые реализации memcpy как раз делаются через rep и movs

Но получается так, что более короткие сложные комманды работают долго, потому что внутри все комманды разбиваются на микроинструкции и более высокоуровневая комманда разбивается на большее число инструкций. Поэтому, например, все оптимизированные версии glibc не используют сложных комманд.

s в коммандах вроде movs означает, что эта комманда для работы со строками. 

В досе нет никакой виртуальной памяти и программа может попортить память программы, которая её вызвала.

highmem - программа могла менять верхний кусок памяти своим кодом и говорить, что максимальная память немного уменьшилась.

как туда передавалось управление? при помощи прерываний.

### protected mode

всё, что было рассказано - про старые технологии (Intel 8086, 8088 и т.д., конец 70-х). Потом появился Intel 80286 - в нём появился protected_mode. Он позволяет изолировать операционную систему от программ и программы друг от друга. Механизм, который появился тогда - segmentation. Перевод - сегментная адресация. 286 могли работать в 2 режимах - защищенный и реальный (совместимый со старыми). Там как раз была эта фишка с seg * 16 + off. А что можно было делать в защищенном? Сегменты лежат не подряд, а разбросаны по памяти. При обращении проверялось, чтобы оффсет не выводил за пределы сегмента.

Ещё можно было сделать уровни привелегий кода. Изначально их было 4. Самый привилигированный - 0. На нём операционная система. На 3 уровне программы. Промежуточные планировались там для драйверов всяких, но на самом деле они не используются в современных операционных системах. 

Как указываются эти базы и лимиты? появился новый регистр, который называется GDTR. Он имел размер шесть байт и представлял из себя 2 байта на лимит (лимит - это размер - 1) + linear address (на оставшиеся 4 байта). 

Что представляла из себя сама таблица? последовательность элементов, где каждый элемент - это некоторый сегмент. 

Один элемент таблицы - 8 байт. Что в них входит? 
limit - 0...15
base (0..15) 16 ... 31
base (16...23)

О сегменте хранится какая-то дополнительная информация. Например, можно ли исполнять данные из этого сегмента? Нет сегментов, которые нельзя писать и исполнять. Уровень привилегий тоже хранится в этой таблице. Какой нужен уровень для обращения к этому сегменту. Самый странный бит - это direction.

В x86 стек растёт вниз. Есть сегменты, у которых обращение идёт от нуля до лимита, а есть сегменты, у которых адреса - отрицательные, т.е. нужно делать проверку, не превысили ли ноль. Ну и направление как раз определяется битом direction.

### различные таблицы дескрипторов
если раньше сегменты клались со смещением в 16 байт, то в защищенном режиме можно было сделать global desctiptor table. В этой таблице хранился адрес начала сегмента, размер (лимит - это размер - 1). + права доступа к этому сегменту. 

(это всё про защищенный режим)

mov ax, 16
mov es, ax // присваивание сегментного регистра
mov es:[0x1234], bl - старый код.

в самом сегменте кроме базы и лимита хранится уровень привилегий. 

в защищенном режиме:
первые 2 бита - это RPL (доступ) 
потом идёт бит global. Затем идёт N - номер в глобальной таблице дескрипторов. 

сегментные регистры на самом деле имеют 80 бит. первые 16 - это то, к чему есть доступ. А остальные - это то, что хранится в глобальной таблице дескрипторов. 

ldt - local descriptor table

(регистры gdt & ldt)

gdt - 48 бит. лдт - 16 бит. Он хранит номер файлового дескриптора, где хранится gdt.

как это использовать? есть 2 программы, у каждой свои сегменты специально для неё. К гдт каждая программа может обращаться. Так что программа могла бы взять сегмент другой программы. Лдт - это как раз механизм защиты. 

А файл дескриптор у каждого процесса свой. (таблица файл дескрипторов) 

call gate - бит из гдт. Если стоит битик, то это сегмент, а если не стоит - то это - call gate.

Суть в том, что должно быть запрещено прыгнуть из низкопривелегированного сегмента в сегмент, где лежит ос и где высокие права доступа. Но иногда это нужно сделать, например, при системных вызовах. Для этого и используется call gate. В нём хранится, кто в него может прыгнуть.

нельзя узнать, где лежат call gate, для этого используются соглашения. В бсд просто договорились, какой селектор будут использовать для системных вызовов.

сейчас этот механизм не используется, потому что у интел он реализован неэффективно. 

Как определяется уровень привилегий кода, который сейчас исполняется? В регистре ... хранится, какой сегмент сейчас исполняется.

В защищенном режиме появилась такая штука, как набор таблиц. IDT - interrupt descriptor table. Таблица дескрипторов прерываний. 

в защищенном режиме нельзя просто так взять и разрешить программам вызывать прерывания. Потому что прерывания могут быть и для устройств. Эта таблица состоит из элементов, которые очень похожи на call gate. Каждый элемент хранит сегмент, смещение, и уровень привилегий, чтобы туда прыгнуть. 

trap gate - он не запрещает прерывания
interrupt gate - запрещает прерывания. разница очень небольшая

процессор позволяет запрещать прерывания. Есть регистр EFLAGS  if - interrupted flag. Если он в true, то прерывания разрешены. Этот флаг значит, могут ли прерывания приходить от устройств. Если прерывания не могут прийти от устройств, то они (прерывания) будут висеть, пока флажок снова не поставят

sti & cli - 

про таблицу дескрипторов прерываний программы могут вообще не знать. Только в одном случае это может понадобиться - когда програма хочет сгенерить прерывание. int 0x80.

у idt данные записаны в регистре - idtr. у таблицы тоже есть база, лимит и всё это хранится в этом регистре.

на винде драйверы могут менять эту таблицу. 

Последний вид дескрипторов, которые бывают в гдт - это TSS

tss - task state segment 

выглядит, как обычный сегмент. Разница в том, что про tss процессор знает что-то про содержимое сегмента. В этом сегменте записано значение всех регистров, сегментных регистров ...

tr - task register. при переключении на какой нибудь tss, процессор читает своё состояние из tss.

Т.е. это поддержка многозадачности на уровне процессора. 

Как это планировалось использовать? Есть глобальная система дескрипторов. + на каждую программу по tss + ещё что-то. Сейчас это не используют, потому что просто сохранить в регистры быстрее, чем использовать tss. Для защиты аля ldt используется страничная адресация.

для системных вызовов сделали (в 386) syscall. И не нужно пользоваться всеми таблицами. Т.е. int использовать не надо. Винда, начиная с висты, использует сискалл.

idt до сих пор используется, например, для старых программ.

Суть в том, что сложные комманды, которые переключают процессы, состоят из более простых. Но они должны работать в общем случае. А если их написать самому, то их можно заточить под конкретное использование.

### INT
Прерывание в ассемблере можно вызвать коммандой INT X, где X - это номер программного прерывания в шестнадцатиричной системе, всего существует 256 таких номеров. Например, INT 21H вызовет программное прерывание 0x21 (33 в десятичной системе). 

Прерывание 0х21 одно из самых часто используемых DOS. Так, вызывав прерывание 21H с различными значениями в регистрах ah и al, мы можем получить доступ к различным операциям ввода/вывода. Есть и другие полезные прерывания: 13Н позволяет работать с дисководом, а 10Н с видео-апаратурой.

В UNIX прерывание 0x80 используется для того, чтобы сделать syscall. Мы вводим 32х-битное значение соответствующее некой системной функции в регистр EAX и затем используем INT 80H, в итоге вынимаем соответствующий syscall из EAX. Мы восхитительны!

Также стоит заметить, что в UNIX-like системах не используются никакие программные прерывания, кроме 0x80.

## ещё про прерывания и системные вызовы (с осей)

#### примеры прерываний
1. таймер
2. double fault - ошибка в обработчике прерываний
3. triple fault - перезагрузка компьютера
4. general protection fault - Когда записали что-то туда, куда нельзя писать. Или попытались попасть в память ядра. 
5. page fault - недопустимая операция с виртуальной памятью. 
6. прерывания, которые бывают, скажем, при делении на 0. 

Прерывания позволяют сделать их и после этого будет исполняться какой-то другой код, но состояние текущего процесса где-то сохранится.

При помощи прерываний можно перейти на уровень ядра прямо в своём процессе. Т.е. обработчик прерывания будет прямо там, где был процесс. Это позволяет ядру узнать, какое нужно сделать прерывание.

в ассемблере можно прерывать в любом месте, главное - это сохранить инстракшн поинтер. Т.е. процесс можно продолжить с любого места. И прервать тоже в любом месте. А это - очень полезно, потому что есть прерывания таймера.

Контекст сохраняется, когда управление передано ядру. Прерывания таймера происходят 100-1000 раз в секунду.

У процессов ещё можно сделать приоритеты, чтобы на один из них тратилось больше процессорного времени. У ядра, соответственно, есть планировщик, который решает, какой процесс сейчас запустить. 

Как аргументы передаются в прерывание? На самом деле, очень сложно, но можно не париться и считать, что в стеке. 

Как уже было сказано, обработчики прерываний вызываются при помощи команды int.

Так как нельзя разрешить кидать любые прерывания, то где-то в коде обработчика прерываний пишется минимальный уровень привилегий, который нужен для вызова этого обработчика. 

Есть ещё способы сделать системные вызовы. Т.е. не только на прерываниях. Зачем делать не на прерываниях? Это долго. Так что добавили ещё пару инструкций: sysenter - управление передаётся на 0 кольцо с нужным стеком, а sysexit - выйти из прерывания и передать управление обратно. Т.е. т.к. для системных вызовов используется одно прерывание, так что можно его оптимизировать.

Ещё можно сделать системный вызов, вызвав несуществующую инструкцию. Для этого даже есть специальное имя инструкции, которое точно не существует: ud2. Для того, чтобы это работало, нужно сделать обработчик прерываний для некорректных инструкций, который будет делать системный вызов.





[<<](https://github.com/Owntage/asm_tickets/blob/master/ticket1.md) [>>](https://github.com/Owntage/asm_tickets/blob/master/ticket4.md)
